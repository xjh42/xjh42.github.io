<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>DLSys: Convolutional Networks</title>
    <url>/2024/08/30/DLSys-Convolutional-Networks/</url>
    <content><![CDATA[<p>In this post, we‚Äôll introduce Convolutional Networks(CNN) with large application.</p>
<h1 id="Theory"><a href="#Theory" class="headerlink" title="Theory"></a>Theory</h1><h2 id="Convolution-Operator"><a href="#Convolution-Operator" class="headerlink" title="Convolution Operator"></a>Convolution Operator</h2><p>So far we only consider fully connected networks, <strong>which treat input images as vectors(size is $n$), and use a large weight matrix($W \in R^{n \times d}$) to map input vector to a feature vector</strong>. This creates a substantial problem as we attempt to handle larger images: a 256x256 RGB image ‚üπ ~200K dimensional input ‚üπ mapping to 1000 dimensional hidden vector requires 200M parameters (for a single layer)</p>
<p>Another problem is this operation <strong>does not capture any of the ‚Äúintuitive‚Äù invariances that we expect to have in images</strong> (e.g., shifting image one pixel leads to very different next layer). It means we use full image pixels to predict single value in next layer.</p>
<img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240830095205371.png" alt="image-20240830095205371" style="zoom:67%;" />

<p>We‚Äôll introduce a new operator convolution to simplify deep networks.</p>
<h3 id="Convolutions-can-‚ÄúSimplify‚Äù-Deep-Networks"><a href="#Convolutions-can-‚ÄúSimplify‚Äù-Deep-Networks" class="headerlink" title="Convolutions can ‚ÄúSimplify‚Äù Deep Networks"></a>Convolutions can ‚ÄúSimplify‚Äù Deep Networks</h3><p>Convolutions combine two ideas that are well-suited to processing images </p>
<ul>
<li>Require that <strong>activations between layers occur only in a ‚Äúlocal‚Äù manner</strong>, and treat hidden layers themselves as spatial images </li>
<li>Share weights across all spatial locations</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240830095715641.png" alt="image-20240830095715641" style="zoom:50%;" />

<p>Compare to full connected network, convolution can:</p>
<ul>
<li>Drastically reduces the parameter count.(256x256 grayscale image ‚üπ 256x256 single-channel hidden layer: 4 billion parameters in fully connected network to 9 parameters in 3x3 convolution)</li>
<li>Captures (some) ‚Äúnatural‚Äù invariances (Shifting input image one pixel to the right shifts creates a hidden shifts the hidden unit ‚Äúimage‚Äù)</li>
</ul>
<p>Let‚Äôs see how convolution works in details</p>
<h3 id="Convolutions-in-detail"><a href="#Convolutions-in-detail" class="headerlink" title="Convolutions in detail"></a>Convolutions in detail</h3><p>Convolutions are a basic primitive in many computer vision and image processing algorithms. Convolution operator is to <strong>‚Äúslide‚Äù the weights $k \times k$ weight $w$  (called a filter, with kernel size $k$) over the image to produce a new image, written $y &#x3D; z * w$</strong>.</p>
<img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240830100303185.png" alt="image-20240830100303185" style="zoom: 33%;" />

<p>let‚Äôs see how to compute $y_{11}$:</p>
<img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240830124621705.png" alt="image-20240830124621705" style="zoom: 33%;" />

<p>The rest value of $y$ is calculated similarly.</p>
<h3 id="Convolutions-in-Image-Processing"><a href="#Convolutions-in-Image-Processing" class="headerlink" title="Convolutions in Image Processing"></a>Convolutions in Image Processing</h3><p>Convolutions (typically with prespecified filters) are a common operation in many computer vision applications: convolution networks just move to learned filters.</p>
<p>For conditional image programming, we use predefined filter, like Gasssian Filter, Image gradient Filter.</p>
<img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240830124932921.png" alt="image-20240830124932921" style="zoom: 33%;" />

<h3 id="Convolutions-in-deep-networks"><a href="#Convolutions-in-deep-networks" class="headerlink" title="Convolutions in deep networks"></a>Convolutions in deep networks</h3><p>Convolutions in deep networks are virtually always multi-channel convolutions: <strong>map multi-channel (e.g., RGB) inputs to multi-channel hidden units</strong>. Multi-channel convolutions contain a convolutional filter for each input-output channel pair, single output channel is sum of convolutions over all input channels. It shows below.</p>
<img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240830125227168.png" alt="image-20240830125227168" style="zoom: 50%;" />

<p>Let‚Äôs see how to define it in math:</p>
<ul>
<li>$x \in R^{h \times w \times c_{in}}$ denotes $c_{in}$ channel, size $h \times w$ image input</li>
<li>$z \in R^{h \times w \times c_{out}}$ denotes $c_{out}$ channel, size $h \times w$ image out</li>
<li>$W \in R^{c_{in} \times c_{out} \times k \times k}$ (order 4 tensor) denotes convolutional filter</li>
</ul>
<p>$$<br>z[:,:,s] &#x3D; \sum_{r&#x3D;1}^{c_{in}}{x[:,:,r] * W[r,s,:,:]}<br>$$</p>
<p>The math equation is hard to understand. There is, in my view, a more intuitive way to think about multi-channel convolutions: <strong>they are a generalization of traditional convolutions with scalar multiplications replaced by matrix-vector products.</strong></p>
<img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240830130039529.png" alt="image-20240830130039529" style="zoom:80%;" />

<h2 id="Elements-of-Practical-Convolutions"><a href="#Elements-of-Practical-Convolutions" class="headerlink" title="Elements of Practical Convolutions"></a>Elements of Practical Convolutions</h2><p>Naive convolution is hard to fit different condition. So there are serveral techniques to make convolution more practical.</p>
<h3 id="Padding"><a href="#Padding" class="headerlink" title="Padding"></a>Padding</h3><p>‚ÄúNa√Øve‚Äù convolutions produce a smaller output than input image. If we want to get a same resolution image, we need use padding technique.Be careful, padding is only work for <strong>odd kernel size</strong>.</p>
<p>For (odd) kernel size $k$,  pad input with $(k-1)&#x2F;2$ zeros on all sides, results in an output that is the same size as the input</p>
<ul>
<li><p>There are serval variants like <strong>circular padding</strong>, <strong>padding with mean values</strong>, etc</p>
<img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240830130634789.png" alt="image-20240830130634789" style="zoom:80%;" /></li>
</ul>
<h3 id="Strided-Convolutions-Pooling"><a href="#Strided-Convolutions-Pooling" class="headerlink" title="Strided Convolutions &#x2F; Pooling"></a>Strided Convolutions &#x2F; Pooling</h3><p>Given input matrix and filter, convolution output a fixed-size of output matrix,  don‚Äôt naively allow for representations at different ‚Äúresolutions‚Äù. If you want to a self-defined size of output matrix, you can use either stride convolution or pooling techniques.</p>
<ul>
<li><p><strong>Pooling</strong> : incorporate max or average pooling layers to aggregate information</p>
<img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240830131034673.png" alt="image-20240830131034673" style="zoom:50%;" />
</li>
<li><p><strong>Strided Convolutions:</strong> slide convolutional filter over image in increments &gt;1 (&#x3D; stride)</p>
<img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240830131143353.png" alt="image-20240830131143353" style="zoom:50%;" />

<h3 id="Grouped-Convolutions"><a href="#Grouped-Convolutions" class="headerlink" title="Grouped Convolutions"></a>Grouped Convolutions</h3><p> For large numbers of input&#x2F;output channels, filters can still have <strong>a large number of weights</strong>, can lead to <strong>overfitting + slow computation</strong>.</p>
<p>To solve this,  we can group together channels, so that **groups of channels in output only depend on corresponding groups of channels in input **(equivalently, enforce filter weight matrices to be block-diagonal)</p>
<img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240830131419161.png" alt="image-20240830131419161" style="zoom:50%;" />

<p>Given a simple example below, we can reduce filter parameter size from $R^{3 \times 3 \times k \times k}$ to $R^{ k \times k}$.</p>
<img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240830131952146.png" alt="image-20240830131952146" style="zoom: 50%;" />

<h3 id="Dilations"><a href="#Dilations" class="headerlink" title="Dilations"></a>Dilations</h3><p> Convolutions each have a <strong>relatively small receptive field size</strong>. We‚Äôll lose the global context of the image.We can use dilation to solve this problem. </p>
<p>Dilate (spread out) convolution filter, so that it covers more of the image; note that getting an image of the same size again requires adding more padding.</p>
<img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240830132217024.png" alt="image-20240830132217024" style="zoom:80%;" /></li>
</ul>
<h2 id="Differentiating-Convolutions"><a href="#Differentiating-Convolutions" class="headerlink" title="Differentiating Convolutions"></a>Differentiating Convolutions</h2><p>Recall the convolution math definition:<br>$$<br>z[:,:,s] &#x3D; \sum_{r&#x3D;1}^{c_{in}}{x[:,:,r] * W[r,s,:,:]}<br>$$</p>
<p>If we use the basic operations like multiply&#x2F;add&#x2F;sum to form convolution and it‚Äôs gradient. The computation graph will be large and cost a lot of memory. So we want to define convolution as basic operator. So it‚Äôll be only single node in a computation graph.</p>
<p>Recall that in order to integrate any operation into a deep network, we need to be able to multiply by its partial derivatives (adjoint operation). So if we define our operation:<br>$$<br>z &#x3D; conv(x, W)<br>$$</p>
<p>how do we multiply by the adjoints:<br>$$<br>\bar{v}\frac{\partial conv(x, W)}{\partial x},\bar{v}\frac{\partial conv(x, W)}{\partial W}<br>$$<br>Let‚Äôs consider the simpler case of a matrix-vector product operation:<br>$$<br>z &#x3D;Wx<br>$$</p>
<p>Then $\frac{\partial z}{\partial x} &#x3D; W$, , so we need to compute the adjoint product:<br>$$<br>\bar{v}^TW \iff W^T\bar{v}<br>$$</p>
<p>In other words, for a matrix vector multiply operation $Wx$, computing the backwards pass requires multiplying by the transpose $W^T$. </p>
<p>In the next section, we can convert convolution to matmul operation, then we can simply get the result of differentiation of convolution.</p>
<h3 id="Convolutions-as-matrix-multiplication-Version-1"><a href="#Convolutions-as-matrix-multiplication-Version-1" class="headerlink" title="Convolutions as matrix multiplication: Version 1"></a>Convolutions as matrix multiplication: Version 1</h3><p>consider a 1D convolution to keep things a bit simpler:</p>
<img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240831123813936.png" alt="image-20240831123813936" style="zoom: 33%;" />

<p>We can write a 1D convolution $x * w$ (e.g., with zero padding) as a matrix multiplication $\hat{W}x$  for some $\hat{W}$ properly defined in terms of the filter $w$.<br>$$<br>\begin{bmatrix} z_1 \ z_2 \ z_3 \ z_4 \ z_5 \end{bmatrix} &#x3D; \begin{bmatrix} w_2 &amp; w_3 &amp; 0  &amp; 0 &amp; 0 \ w_1 &amp; w_2 &amp; w_3  &amp; 0 &amp; 0 \ 0 &amp; w_1 &amp; w_2  &amp; w_3 &amp; 0 \ 0 &amp; 0 &amp; w_1  &amp; w_2 &amp; w_3 \ 0 &amp; 0 &amp; 0  &amp; w_1 &amp; w_2 \end{bmatrix} \begin{bmatrix} x_1 \ x_2 \ x_3 \ x_4 \ x_5 \end{bmatrix}<br>$$<br>By converting convolution to matmul, we can easily compute the gradient of convolution. Just compute the transponse of $\hat{W}$:</p>
<img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240831215657389.png" alt="image-20240831215657389" style="zoom: 40%;" />

<p>Notice that the operation $\hat{W}^Tv$ it itself just a convolution with the ‚Äúflipped‚Äù filter: $[w_3 \space w_2 \space w_1]$ &#x3D;&#x3D;&gt; <strong>adjoint operator $\bar{v}\frac{\partial conv(x, W)}{\partial x}$ just requires convolving $\bar{v}$ with a the flipped $W$</strong>.</p>
<h3 id="Convolutions-as-matrix-multiplication-Version-2"><a href="#Convolutions-as-matrix-multiplication-Version-2" class="headerlink" title="Convolutions as matrix multiplication: Version 2"></a>Convolutions as matrix multiplication: Version 2</h3><p>What about the other adjoint,$\bar{v}\frac{\partial conv(x, W)}{\partial W}$?</p>
<p>For this term, observe that we can also write the convolution as <strong>a matrix-vector product treating the filter as the vector</strong>.<br>$$<br>\begin{bmatrix} z_1 \ z_2 \ z_3 \ z_4 \ z_5 \end{bmatrix} &#x3D; \begin{bmatrix} 0 &amp; x_1 &amp; x_2 \ x_1 &amp; x_2 &amp; x_3 \ x_2 &amp; x_3 &amp; x_4 \ x_3 &amp; x_4 &amp; x_5 \ x_4 &amp; x_5 &amp; 0 \end{bmatrix} \begin{bmatrix} w_1 \ w_2 \ w_3 \end{bmatrix}<br>$$</p>
<p>So adjoint requires multiplying by the transpose of this $x$-based matrix:<br>$$<br>\begin{bmatrix} 0 &amp; x_1 &amp; x_2 &amp; x_3 &amp; x_4 \ x_1 &amp; x_2 &amp; x_3 &amp; x_4 &amp; x_5 \ x_2 &amp; x_3 &amp; x_4 &amp; x_5 &amp; 0 \end{bmatrix}<br>$$</p>
<h1 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h1><p>The reference implementation is <a href="https://colab.research.google.com/drive/1N6MtkNXq6QOpGYhXTokOjWvkF3Ff9i8Z?usp=sharing">here</a></p>
]]></content>
      <categories>
        <category>dlsys</category>
      </categories>
      <tags>
        <tag>transformer</tag>
      </tags>
  </entry>
  <entry>
    <title>DLSys: ML Refresher / Softmax Regression</title>
    <url>/2024/09/24/DLSys-ML-Refresher-Softmax-Regression/</url>
    <content><![CDATA[<p>In this post, I‚Äôll introduce the machine learning basics.</p>
<h1 id="Machine-Learning-Basics"><a href="#Machine-Learning-Basics" class="headerlink" title="Machine Learning Basics"></a>Machine Learning Basics</h1><p>Suppose you want to write a program that will classify handwritten drawing of digits into their appropriate category: 0,1,‚Ä¶,9. You could, think hard about the nature of digits, try to determine the logic of what indicates what kind of digit, and write a program to codify this logic (Despite being a reasonable coder, I don‚Äôt think I could do this very well)</p>
<img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240924091119545.png" alt="image-20240924091119545" style="zoom: 45%;" />

<p>The (supervised) <strong>ML approach</strong>: collect a training set of images with known labels and feed these into a machine learning algorithm, which will (if done well), automatically produce a ‚Äúprogram‚Äù that solves this task.</p>
<img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240924091220614.png" alt="image-20240924091220614" style="zoom:50%;" />

<p>Every machine learning algorithm consists of three different elements:</p>
<ol>
<li><strong>The hypothesis class(the model)</strong>: the ‚Äúprogram structure‚Äù, parameterized via a set of parameters, that describes how we map inputs (e.g., images of digits) to outputs (e.g., class labels, or probabilities of different class labels)</li>
<li><strong>The loss function:</strong> a function that specifies how ‚Äúwell‚Äù a given hypothesis (i.e., a choice of parameters) performs on the task of interest</li>
<li><strong>An optimization method:</strong>  a procedure for determining a set of parameters that (approximately) minimize the sum of losses over the training set</li>
</ol>
<h1 id="softmax-regression"><a href="#softmax-regression" class="headerlink" title="softmax regression"></a>softmax regression</h1><p>Softmax regression is a basic method to solve <em>k-class classification</em>  problem. Let‚Äôs first define the problem:</p>
<h2 id="Multi-class-classification-setting"><a href="#Multi-class-classification-setting" class="headerlink" title="Multi-class classification setting"></a>Multi-class classification setting</h2><p>Let‚Äôs consider a k-class classification setting, where we have:</p>
<ul>
<li><strong>Training data</strong>: $x^{(i)} \in R^n$, and $y^{(i)} \in {1,‚Ä¶,k}$ for $i \in {1,..,m}$</li>
<li>ùëõ &#x3D; dimensionality of the input data</li>
<li>ùëò &#x3D; number of different classes &#x2F; labels</li>
<li>ùëö &#x3D; number of points in the training set</li>
</ul>
<p>Example: classification of 28x28 MNIST digits:</p>
<ul>
<li>ùëõ &#x3D; 28 ‚ãÖ 28 &#x3D; 784 </li>
<li>ùëò &#x3D; 10 </li>
<li>ùëö &#x3D; 60,000</li>
</ul>
<h2 id="Three-Element-of-Softmax-Regression"><a href="#Three-Element-of-Softmax-Regression" class="headerlink" title="Three Element of Softmax Regression"></a>Three Element of Softmax Regression</h2><h3 id="Linear-hypothesis-function"><a href="#Linear-hypothesis-function" class="headerlink" title="Linear hypothesis function"></a>Linear hypothesis function</h3><p>Our hypothesis function maps inputs $x \in R^n$  to ùëò-dimensional vectors:<br>$$<br>h: R^n \to R^k<br>$$<br>where $h_i(x), i \in {1,..k}$ indicates some measure of ‚Äúbelief‚Äù in how much likely the label is to be class ùëñ (i.e., ‚Äúmost likely‚Äù prediction is coordinate ùëñ with largest $h_i(x)$.)</p>
<p>A <strong>linear hypothesis function</strong> uses a linear operator (i.e. matrix multiplication) for this transformation:<br>$$<br>h_\theta(x) &#x3D; \theta^Tx<br>$$<br>for parameters $\theta \in R^{n \times k}$</p>
<p>Often more convenient (and this is how you want to code things for efficiency) to write the data and operations in <strong>matrix batch form</strong>:</p>
<img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240924093023427.png" alt="image-20240924093023427" style="zoom:33%;" />

<p>Then the linear hypothesis applied to this batch can be written as:</p>
<img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240924093044172.png" alt="image-20240924093044172" style="zoom:33%;" />

<h3 id="Loss-Function"><a href="#Loss-Function" class="headerlink" title="Loss Function"></a>Loss Function</h3><p>The simplest loss function to use in classification is just the <strong>classification error</strong>, i.e., whether the classifier makes a mistake a or not:</p>
<img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240924093324238.png" alt="image-20240924093324238" style="zoom:33%;" />

<p>We typically use this loss function to assess the quality of classifiers.</p>
<p>Unfortunately, the error is a bad loss function to use for optimization, i.e., selecting the best parameters, because it is not differentiable.</p>
<h3 id="softmax-cross-entropy-loss"><a href="#softmax-cross-entropy-loss" class="headerlink" title="softmax &#x2F; cross-entropy loss"></a>softmax &#x2F; cross-entropy loss</h3><p>Let‚Äôs convert the hypothesis function to a ‚Äúprobability‚Äù by <strong>exponentiating and normalizing its entries</strong> (to make them all positive and sum to one):<br>$$<br>z_i &#x3D; p(label&#x3D;i) &#x3D; \frac{exp(h_i(x))}{\sum_{j&#x3D;1}^kexp(h_j(x))} &#x3D; norm(exp(h(y))<br>$$<br>Then let‚Äôs define a loss to be the (negative) log probability of the true class: this is called softmax or cross-entropy loss :<br>$$<br>l_{ce}(h(x),y) &#x3D; -log(p(label&#x3D;y)) &#x3D; -h_y(x) + log\sum_{j&#x3D;1}^kexp(h_j(x))<br>$$</p>
<h3 id="Softmax-Regression-Optimization-Method-Stochastic-Gradient-Descent"><a href="#Softmax-Regression-Optimization-Method-Stochastic-Gradient-Descent" class="headerlink" title="Softmax Regression Optimization Method: Stochastic Gradient Descent"></a>Softmax Regression Optimization Method: Stochastic Gradient Descent</h3><p>The third ingredient of a machine learning algorithm is a method for solving the associated optimization problem, i.e., the problem of minimizing the average loss on the training set:</p>
<img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240924094501602.png" alt="image-20240924094501602" style="zoom:33%;" /> 

<p>So how do we find Œò that solves this optimization problem?</p>
<p>For a matrix-input, scalar output function $f: R^{n \times k} \to R$  the gradient is defined as the matrix of partial derivatives:</p>
<img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240924094719645.png" alt="image-20240924094719645" style="zoom: 67%;" />

<p>Gradient points in the direction that most increases ùëì (locally).</p>
<p>To minimize a function, the gradient descent algorithm proceeds by <strong>iteratively taking steps in the direction of the negative gradient</strong>:</p>
<img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240924094943710.png" alt="image-20240924094943710" style="zoom:50%;" />

<p>where ùõº &gt; 0 is a step size or learning rate:</p>
<img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240924095031145.png" alt="image-20240924095031145" style="zoom:50%;" />

<p>If our objective (as is the case in machine learning) is the sum of individual losses, we don‚Äôt want to compute the gradient using all examples to make a single update to the parameters.</p>
<p>Instead, take many gradient steps each based upon a minibatch (small partition of the data), to make many parameter updates using a single ‚Äúpass‚Äù over data</p>
<img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240924095218315.png" alt="image-20240924095218315" style="zoom:50%;" />

<p>So, how do we compute the gradient for the softmax objective?</p>
<img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240924095421785.png" alt="image-20240924095421785" style="zoom:40%;" />

<p>Let‚Äôs start by deriving the gradient of the softmax loss itself: for vector $h \in R^k$:</p>
<img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240924095509447.png" alt="image-20240924095509447" style="zoom:33%;" />

<p>So, in vector form: $\bigtriangledown_hl_{ce}(h,y)&#x3D;z-e_y$, where ùëß &#x3D; norm(exp(h)).</p>
<p>Then, let‚Äôs compute the ‚Äúderivative‚Äù of the loss:</p>
<img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240924100156250.png" alt="image-20240924100156250" style="zoom:33%;" />

<p>So to make the dimensions work:</p>
<img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240924100246907.png" alt="image-20240924100246907" style="zoom:33%;" />

<p>Same process works if we use ‚Äúmatrix batch‚Äù form of the loss:</p>
<img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240924100441453.png" alt="image-20240924100441453" style="zoom:33%;" />

<h2 id="Softmax-Regression-All-in-One"><a href="#Softmax-Regression-All-in-One" class="headerlink" title="Softmax Regression All in One"></a>Softmax Regression All in One</h2><p>Despite a fairly complex derivation, we should highly just how simple the final algorithm is:</p>
<ul>
<li>Repeat until parameters &#x2F; loss converges <ul>
<li>Iterative over minibatches $X \in R^{B \times n}, y \in {1,‚Ä¶,k}^B$ of training set </li>
<li>Update the parameters $\theta &#x3D; \theta - \frac{\alpha}{B}X^T(Z - I_y)$</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>dlsys</category>
      </categories>
      <tags>
        <tag>ml_basics</tag>
      </tags>
  </entry>
  <entry>
    <title>DLSys: Manual Neural Networks</title>
    <url>/2024/09/24/DLSys-Manual-Neural-Networks/</url>
    <content><![CDATA[<p>In this post, I‚Äôll introduce nerual network basics.</p>
<h1 id="Nonlinear-hypothesis-classes"><a href="#Nonlinear-hypothesis-classes" class="headerlink" title="Nonlinear hypothesis classes"></a>Nonlinear hypothesis classes</h1><h1 id="Neural-networks"><a href="#Neural-networks" class="headerlink" title="Neural networks"></a>Neural networks</h1><h1 id="Backpropagation"><a href="#Backpropagation" class="headerlink" title="Backpropagation"></a>Backpropagation</h1>]]></content>
      <categories>
        <category>dlsys</category>
      </categories>
      <tags>
        <tag>nn_basics</tag>
      </tags>
  </entry>
  <entry>
    <title>DLSys: Sequence Modeling and Recurrent Networks</title>
    <url>/2024/08/24/DLSys-Sequence-Modeling-and-Recurrent-Networks/</url>
    <content><![CDATA[<h2 id="Theory"><a href="#Theory" class="headerlink" title="Theory"></a>Theory</h2><h3 id="Sequence-Modeling"><a href="#Sequence-Modeling" class="headerlink" title="Sequence Modeling"></a>Sequence Modeling</h3><p>For the previous posts, we make prediction assuming input and output pairs $(x^{(i)}, y^{(i)})$  is <strong>independent identically distributed(i.i.d)</strong>.It means the previous result donnot affect current result. In pratice, many cases where <strong>the input&#x2F;output pairs are given in a specific sequence</strong>, and we need to use the information about this sequence to help us make predictions.</p>
<img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240824173117956.png" alt="image-20240824173117956" style="zoom:67%;" />

<ul>
<li><strong>Part of speech tagging</strong>: Given a sequence of words, determine the part of speech of each word.<strong>A word‚Äôs part of speech depends on the context in which it is being used</strong>, not just on the word itself.</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240824173242176.png" alt="image-20240824173242176"></p>
<ul>
<li><strong>speech to text</strong>: Given a audio signal (assume we even know the word boundaries, and map each segment to a fix-sized vector descriptor), determine the corresponding transcription. Again, context of the words is extremely important. Because many words‚Äô pronunciation are same.  (see e.g., any bad speech recognition system that attempts to ‚Äúwreck a nice beach‚Äù)</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240824173452738.png" alt="image-20240824173452738"></p>
<ul>
<li><strong>autoregressive prediction</strong>: A special case of sequential prediction where the elements to predict is the next element in the sequence.Common e.g., in time series forecasting, language modeling, and other use cases. We strongly rely on the context of the sentance to predict the next word.</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240824173627222.png" alt="image-20240824173627222"></p>
<h3 id="Recurrent-Neural-Networks"><a href="#Recurrent-Neural-Networks" class="headerlink" title="Recurrent Neural Networks"></a>Recurrent Neural Networks</h3><p>Recurrent neural networks (RNNs) is a model to save the sequence model problem.  RNN maintain a <strong>hidden state</strong> over time, which is a function of the current input and previous hidden state. The previous hidden state contains the context of the previous inputs. Therefore, hidden state use the current input and a list of previous inputs to make a prediction. </p>
<img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240826092058694.png" alt="image-20240826092058694" style="zoom:50%;" />
$$
h_t = f(W_{hh}h_{t-1} + W_{hx}x_t + b_h)
$$

<p>$$<br>y_t &#x3D; g(W_{yh} + b_y)<br>$$</p>
<p>Where $f$ and $g$ are activation function. $W_{hh}$ , $W_{hx}$, $W_{yh}$ are weights, and $b_y$, $b_h$ are bias term. And $x \in R^n$,  $y \in R^{k}$, $h_t \in R^d$, $W_{hh} \in R^{d \times d}$, $W_{yh} \in R^{k \times d}$, $W_{hx} \in R^{d \times n}$, $b_h \in R^d$, $b_y \in R^k$.</p>
<p>After we define the RNN model, the next question is how to train RNN? Given a sequence of inputs and target outputs$(x_1, ‚Ä¶, x_T, y^{<em>}_1, ‚Ä¶, y^{</em>}_T)$, we can train an RNN using backpropagation through time, which just involves ‚Äúunrolling‚Äù the RNN over the length of the sequence, then relying mostly on <strong>autodiff</strong>. Without autodiff, we cannot solve the problem, because we cannot write the gradient of the rnn model.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">opt = Optimizer(params = (W_hh, W_hx, W_yh, b_h, b_y))</span><br><span class="line">h[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">l = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> t = <span class="number">1</span>,...,T:</span><br><span class="line">  h[t] = f(W_hh * h[t-<span class="number">1</span>] + W_hx * x[t] + b_h)</span><br><span class="line">  y[t] = g(W_yh * h[t] + b_y)</span><br><span class="line">  l += Loss(y[t], y_star[t])</span><br><span class="line">l.backward()</span><br><span class="line">opt.step()</span><br></pre></td></tr></table></figure>



<p>As you can see, the challenge for training RNNs is similar to that of training deep MLP networks, becasuse the sequence maybe long and the rnn is complicated.</p>
<ul>
<li><p><strong>Exploding activations&#x2F;gradients</strong>: Because we train RNNs on long sequences, if the weights&#x2F;activation of the RNN are scaled poorly, the hidden activations (and therefore also the gradients) will grow unboundedly with sequence length. For example, we use below initialization, the gradient will soon be NaN which cannot be stored in the 32-bit floating number.</p>
<p><img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240826094116833.png" alt="image-20240826094116833"></p>
</li>
<li><p><strong>Vanishing activation&#x2F;gradients</strong>: Similarly, if weights are too small then information from the inputs will quickly decay with time (and it is precisely the ‚Äúlong range‚Äù dependencies that we would often like to model with sequence models). So the context of the previous  inputs will decay.</p>
<p><img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240826094344394.png" alt="image-20240826094344394"></p>
</li>
</ul>
<p>To solve <strong>Exploding activations&#x2F;gradients</strong> problem, we can use other activation functions. ReLU is a bad activation function because it can grow unboundedly. We can use sigmod and tanh activation function.</p>
<p><img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240826094802233.png" alt="image-20240826094802233"></p>
<p>But the problem <strong>Vanishing activation&#x2F;gradients</strong> still be unsolved. Creating large enough weights to not cause activations&#x2F;gradients to vanish requires being in <strong>the ‚Äúsaturating‚Äù regions of the activations</strong>, where gradients are very small ‚üπ still have vanishing gradients</p>
<p>How solve this problems? Use LSTM!</p>
<h3 id="LSTMs"><a href="#LSTMs" class="headerlink" title="LSTMs"></a>LSTMs</h3><p>Long short term memory (LSTM) cells are a particular form of hidden unit update that avoids (some of) the problems of vanilla LSTMs. It make two changes to avoid vanishing activation&#x2F;gradients.</p>
<ul>
<li><p>Step 1:  Divide the hidden unit into two components, called (confusingly) the <strong>hidden state</strong> and the <strong>cell state</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240826095305637.png" alt="image-20240826095305637"></p>
<ul>
<li><p>Step 2: Use a very specific formula to update the hidden state and cell state (throwing in some other names, like ‚Äúforget gate‚Äù, ‚Äúinput gate‚Äù, ‚Äúoutput gate‚Äù for good measure)</p>
<p><img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240826095513339.png" alt="image-20240826095513339"></p>
<p>where $i_t \in R^d$, $f_t \in R^d$,$g_t \in R^d$, $o_t \in R^d$, $W_{hh} \in R^{4d \times d}$, $h_t \in R^d$ , $W_{hx} \in R^{4d \times n}$</p>
</li>
</ul>
</li>
</ul>
<p>Why LSTM works? The factor of $f_t$ and $i_t$ can control the context information. Close to 0 ‚Äì&gt; not mantain the context, Close 1 ‚Äì&gt; context information will be untoched.</p>
<p><img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240826100216569.png" alt="image-20240826100216569"></p>
<h3 id="Beyond-‚Äúsimple‚Äù-sequential-Models"><a href="#Beyond-‚Äúsimple‚Äù-sequential-Models" class="headerlink" title="Beyond ‚Äúsimple‚Äù sequential Models"></a>Beyond ‚Äúsimple‚Äù sequential Models</h3><p>We‚Äôll introduce a list of aplication of RNN.</p>
<ul>
<li><p><strong>Seq2Seq model</strong>: To give you a short glimpse of the kind of things you can do with RNNs&#x2F;LSTMs beyond ‚Äúsimple‚Äù sequence prediction, consider the task of <strong>trying to translate between languages</strong>. </p>
<p>Can concatenate two RNNs together, one that ‚Äúonly‚Äù processes the sequence to create a final hidden state (i.e., no loss function, encoder); then a section that takes in this initial hidden state, and ‚Äúonly‚Äù generates a sequence(decoder). Why this model works? Because the translation task is not a one-one mapping problem.</p>
<p><img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240826100555240.png" alt="image-20240826100555240"></p>
<p>$h_5$ contains the summary of the context.</p>
</li>
<li><p><strong>Bidirectional RNNs</strong>: RNNs can use only the sequence information up until time $t$ to predict $y_t$.This is sometimes desirable (e.g., autoregressive models). But sometime undesirable (e.g., language translation where we want to use ‚Äúwhole‚Äù input sequence)</p>
<p>Bi-directional RNNs stack a forwardrunning RNN with a backward-running RNN: information from the entire sequence to propagates to the hidden state. So we can use the full context to predict!</p>
<p><img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240826101002495.png" alt="image-20240826101002495"></p>
</li>
</ul>
<h2 id="Implementing-RNNs"><a href="#Implementing-RNNs" class="headerlink" title="Implementing RNNs"></a>Implementing RNNs</h2><p>Codelab notebook links: <a href="https://colab.research.google.com/drive/1c8fmSa1H9noi_1RJhFOksloEFNDrEmU7?usp=sharing">implementing RNNs</a></p>
]]></content>
      <categories>
        <category>dlsys</category>
      </categories>
      <tags>
        <tag>rnn</tag>
      </tags>
  </entry>
  <entry>
    <title>DLSys: Transformers and Attention</title>
    <url>/2024/08/27/DLSys-Transformers-and-Autoregressive-Models/</url>
    <content><![CDATA[<h2 id="Theory"><a href="#Theory" class="headerlink" title="Theory"></a>Theory</h2><h3 id="The-two-approaches-to-time-series-modeling"><a href="#The-two-approaches-to-time-series-modeling" class="headerlink" title="The two approaches to time series modeling"></a>The two approaches to time series modeling</h3><p>Let‚Äôs recall our basic time series prediction task from the previous posts. More fundamentally, a time series prediction task is the task of predicting:<br>$$<br>y_{1:T}&#x3D;f_\theta(x_{1:T})<br>$$<br><img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240828130234284.png" alt="image-20240828130234284" style="zoom:50%;" /></p>
<p>where $y_t$ can depend only on $x_{1:t}$. There are mainly two approach to do so: <strong>latent state approach</strong> and <strong>direct prediction</strong>.</p>
<h4 id="The-RNN-‚Äúlatent-state‚Äù-approach"><a href="#The-RNN-‚Äúlatent-state‚Äù-approach" class="headerlink" title="The RNN ‚Äúlatent state‚Äù approach"></a>The RNN ‚Äúlatent state‚Äù approach</h4><p>We have already seen the RNN approach to time series: <strong>maintain ‚Äúlatent state‚Äù $h_t$ that summarizes all information up until that point</strong>.</p>
<img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240828130718884-20240828130724791.png" alt="image-20240828130718884" style="zoom: 33%;" />

<ul>
<li><strong>Pros</strong>: Potentially ‚Äúinfinite‚Äù history, compact representation. It means the time series length is not limited and has low memory to store the previous context.</li>
<li><strong>Cons</strong>:  Long ‚Äúcompute path‚Äù between history and current time ‚üπ vanishing &#x2F; exploding gradients, hard to learn. A single state $h_t$ is hard to represent long context, easily lost the previous context.</li>
</ul>
<h4 id="The-‚Äúdirect-prediction‚Äù-approach"><a href="#The-‚Äúdirect-prediction‚Äù-approach" class="headerlink" title="The ‚Äúdirect prediction‚Äù approach"></a>The ‚Äúdirect prediction‚Äù approach</h4><p>To avoid vanishing&#x2F;exploding gradients(lose context&#x2F;context is hard to store), we can also directly predict output $y_t$:<br>$$<br>y_t &#x3D; f_\theta(x_{1:t})<br>$$<br>$f_\theta$ must be a function that can make predictions of differently-sized inputs.</p>
<img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240828131152642.png" alt="image-20240828131152642" style="zoom:33%;" />

<ul>
<li><strong>Pros</strong>:  Often can map from past to current state with shorter compute path. With a proper function $f_\theta$ , we can avoid vanishing&#x2F;exploding gradients.</li>
<li><strong>Cons</strong>: No compact state representation, finite history in practice.</li>
</ul>
<p>One of the most straightforward ways to specify the function $f_\theta$: (fully) convolutional networks, a.k.a. temporal convolutional networks (TCNs). The main constraint is that <strong>the convolutions be causal</strong>: $z^{i+1}<em>t$ can only depend on $z^{i}</em>{t-k:t}$.</p>
<p>Many successful applications: e.g. WaveNet for speech generation (<a href="https://deepmind.google/discover/blog/wavenet-a-generative-model-for-raw-audio/">van den Oord et al., 2016</a>)</p>
<img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240828132255771.png" alt="image-20240828132255771" style="zoom:67%;" />

<p>Despite their simplicity, CNNs have a notable disadvantage for time series prediction: the receptive field of each convolution is usually relatively small ‚üπ need deep networks to actually incorporate past information. For example, WaveNet can achive a receptive field of 16 using 4 layer. For very long sequence, it will need very deep network. There are several solutions:</p>
<ul>
<li><strong>Increase kernel size</strong>: also increases the parameters of the network</li>
<li><a href="https://medium.com/@abhishekjainindore24/pooling-and-their-types-in-cnn-4a4b8a7a4611"><strong>Pooling layers</strong></a>: not as well suited to dense prediction, where we want to predict all of $y_{1:T}$. We‚Äôll lose some predictions because pooling will decrease the size of input.(alose decrease the size of output)</li>
<li><strong>Dilated convolutions</strong>: ‚ÄúSkips over‚Äù some past state &#x2F; inputs. But we‚Äôll lose some context which may be important.</li>
</ul>
<p>As we can see, CNN is not well suited for time series prediction. We‚Äôll introduce a new arch of network: transformer which will overcome the cons of CNN.</p>
<h3 id="Self-attention-and-Transformers"><a href="#Self-attention-and-Transformers" class="headerlink" title="Self-attention and Transformers"></a>Self-attention and Transformers</h3><h4 id="Self-Attention"><a href="#Self-Attention" class="headerlink" title="Self Attention"></a>Self Attention</h4><p>Let‚Äôs first talk about the important part of transformer: <strong>Self Attention</strong>! ‚ÄúAttention‚Äù in deep networks generally refers to <strong>any mechanism where individual states are weighted and then combined</strong>.</p>
<img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240829085656637.png" alt="image-20240829085656637" style="zoom:50%;" />

<p>Attention is used originally in RNNs when one wanted to combine latent states over all times in a more general manner than ‚Äújust‚Äù looking at the last state. Let‚Äôs define general attention in math:<br>$$<br>z_t &#x3D; \theta^Th_t^k<br>$$</p>
<p>$$<br>w &#x3D; softmax(z)<br>$$</p>
<p>$$<br>\bar{h} &#x3D; \sum_{t&#x3D;1}^T(w_th_t^k)<br>$$</p>
<blockquote>
<p>The <strong>softmax function</strong> converts a vector of <em>K</em> real numbers into a <a href="https://en.wikipedia.org/wiki/Probability_distribution">probability distribution</a> of <em>K</em> possible outcomes. </p>
</blockquote>
<p><strong>Self-attention</strong> refers to a particular form of attention mechanism. Given three inputs $K,Q,V \in R^{T \times d}$, (‚Äúqueries‚Äù, ‚Äúkeys‚Äù, ‚Äúvalues‚Äù, in one of the least-meaningful semantic designations we have in deep learning).</p>
<img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240829090838397.png" alt="image-20240829090838397" />

<p>we define the self attention operation as:<br>$$<br>SelfAttetion(Q,K,V)&#x3D;softmax(\frac{QK^T}{d^{1&#x2F;2}})V<br>$$<br>Where the input is $X \in R^{T \times n}, W_k \in W^{n \times d}, W_Q \in W^{n \times d}, W_V \in W^{n \times d}$, we can simple calculate $Q, K, V$ as follows:<br>$$<br>Q &#x3D; XW_Q<br>$$</p>
<p>$$<br>K &#x3D; XW_K<br>$$</p>
<p>$$<br>V &#x3D; XW_V<br>$$</p>
<p>Compare to the attention used in rnn, we use input to replace the hidden state $h$.</p>
<img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240829092012276.png" alt="image-20240829092012276" style="zoom:50%;" />

<p>Properties of self-attention:</p>
<ul>
<li>Invariant (really, equivariant) to permutations of the $Q, K, V$matrices </li>
<li>Allows influence between $q_t,k_t, v_t$over all times without increase parameter size.(compare to CNN, in order to increase reception field, we need to increase kernel size ‚Äì&gt; increase parameter size)</li>
<li>Compute cost is $O(T^2 + 2Td)$ (cannot be easily reduced due to nonlinearity applied to full $T \times T$ matrix)</li>
<li>softmax const $T^2$</li>
<li>two matrix multiplication cost $Td$</li>
</ul>
<h4 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h4><p>A simple transoformer block consist of  self-attention mechanism and other network blocks.</p>
<img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240829092949134.png" alt="image-20240829092949134" style="zoom:50%;" />

<p>In more detail, the Transformer block has the following form:</p>
<img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240829093117580.png" alt="image-20240829093117580" style="zoom: 33%;" />

<p>The Transformer architecture uses a series of attention mechanisms (and feedfoward layers) to process a time series:</p>
<img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240829093229868.png" alt="image-20240829093229868" style="zoom: 50%;" />

<p>Which can be form use math equation below:<br>$$<br>Z^{(i+1)}&#x3D;TransformerBlock(Z^{(i)})<br>$$<br>All time steps (in practice, within a given time slice) are <strong>processed in parallel</strong>, avoids the need for sequential processing as in RNNs.</p>
<p>We can apply the Transformer block to the ‚Äúdirect‚Äù prediction method for time series, instead of using a convolutional block.</p>
<ul>
<li><p>Pros:</p>
<ul>
<li>Full receptive field within a single layer (i.e., can immediately use past data) </li>
<li>Mixing over time doesn‚Äôt increase parameter count (unlike convolutions)</li>
</ul>
</li>
<li><p>Cons:</p>
<ul>
<li>All outputs depend on all inputs (no good e.g., for autoregressive tasks)  ‚Äì the latent cortex is more important.</li>
<li>No ordering of data (remember that transformers are equivariant to permutations of the sequence)‚Äìthe position masters.</li>
</ul>
</li>
</ul>
<p>To solve the cons of transformer, we introduce two techniques: <strong>masked self-attention</strong>, and <strong>Positional encodings</strong>.</p>
<h4 id="Masked-self-attention"><a href="#Masked-self-attention" class="headerlink" title="Masked self-attention"></a>Masked self-attention</h4><p>To solve the problem of ‚Äúacausal‚Äù dependencies, we can mask the softmax operator to assign zero weight to any ‚Äúfuture‚Äù time steps.</p>
<img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240829094005050.png" alt="image-20240829094005050" style="zoom: 50%;" />

<p>Note that even though technically this means we can ‚Äúavoid‚Äù creating those entries in the attention matrix to being with, in practice it‚Äôs often faster to just form them then mask them out.</p>
<img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240829094241280.png" alt="image-20240829094241280" style="zoom:50%;" />

<h4 id="Positional-encodings"><a href="#Positional-encodings" class="headerlink" title="Positional encodings"></a>Positional encodings</h4><p>To solve the problem of ‚Äúorder invariance‚Äù, we can add a positional encoding to the input, which <strong>associates each input with its position in the sequence</strong>.</p>
<img src="https://cdn.jsdelivr.net/gh/xjh42/oss@main/uPic/image-20240829094534849.png" alt="image-20240829094534849" style="zoom:50%;" />

<p>and where $w_i, i &#x3D; 1,‚Ä¶,n$ is typically chosen according to a logarithmic schedule. Really, add positional encoding to d-dimensional projection of $T$</p>
<h3 id="Transformers-beyond-time-series"><a href="#Transformers-beyond-time-series" class="headerlink" title="Transformers beyond time series"></a>Transformers beyond time series</h3><p>Recent work has observed that transformer blocks are extremely powerful beyond just time series</p>
<ul>
<li>Vision Transformers: Apply transformer to image (represented by a collection of patch embeddings), works better than CNNs for large data sets</li>
<li>Graph Transformers: Capture graph structure in the attention matrix</li>
</ul>
<p>In all cases, some challenges are: </p>
<ul>
<li>How to represent data such that $O(T^2)$ operations are feasible </li>
<li>How to form positional embeddings </li>
<li>How to form the mask matrix</li>
</ul>
<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><p>The runnable colab implementation is <a href="https://colab.research.google.com/drive/1sSkoJhexTDEgdBahAIm2SeV0Eqc0frj2?usp=sharing">here</a></p>
]]></content>
      <categories>
        <category>dlsys</category>
      </categories>
      <tags>
        <tag>transformer</tag>
      </tags>
  </entry>
</search>
